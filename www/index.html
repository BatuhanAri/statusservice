<script type="module">
  // --------------------
  // Genel config
  // --------------------
  const CONFIG = Object.freeze({
    POLL_MS: 5000,
    ENDPOINTS: {
      HEALTH: '/api/health',
      RUN: '/api/run',
      SYSTEMD: '/api/system-services',   // systemd durumları için
    },
    LABELS: {
      present: 'Present',
      port: 'Port',
      http: 'HTTP',
      portErr: 'Port Hatası',
      httpErr: 'HTTP Hatası',
      systemd: 'Systemd',
    },
  });

  // --------------------
  // Küçük yardımcılar
  // --------------------
  const el = (tag, attrs = {}, children = []) => {
    const node = document.createElement(tag);

    for (const [key, value] of Object.entries(attrs)) {
      if (value == null) continue;
      if (key === 'className') node.className = value;
      else if (key === 'dataset') Object.assign(node.dataset, value);
      else if (key in node) node[key] = value;
      else node.setAttribute(key, String(value));
    }

    if (!Array.isArray(children)) children = [children];
    for (const child of children) {
      if (child == null) continue;
      node.append(child instanceof Node ? child : document.createTextNode(String(child)));
    }
    return node;
  };

  const chip = (cls, title) =>
    el('span', {
      className: `chip ${cls}`,
      role: 'img',
      ariaLabel: title || '',
      title: title || '',
    });

  const chipBool = (v) => {
    if (v === true) return chip('ok', 'Evet');
    if (v === false) return chip('bad', 'Hayır');
    return chip('na', 'NA');
  };

  const rh = (state) =>
    el('span', {
      className: `rh ${state}`,
      role: 'img',
      ariaLabel:
        state === 'ok' ? 'Sağlıklı' : state === 'warn' ? 'Uyarı' : 'Sağlıksız',
      title: state === 'ok' ? 'Sağlıklı' : state === 'warn' ? 'Uyarı' : 'Sağlıksız',
    });

  const makeRow = (labelText, valueNode) =>
    el('div', { className: 'row' }, [
      el('span', { className: 'label', textContent: labelText }),
      el('span', { className: 'val' }, valueNode),
    ]);

  const makeDivider = () =>
    el('div', { className: 'hr', role: 'separator', ariaHidden: 'true' });

  // --------------------
  // Sağlık kuralları
  // --------------------
  const httpApplicable = (obj) =>
    'http_ok' in obj || 'status' in obj || 'error' in obj || 'http_path' in obj;

  const isHealthy = (obj) => {
    const presentOk = obj.present === true;
    const portOk = obj.port_ok === true;
    const httpOk = httpApplicable(obj) ? obj.http_ok === true : true;
    return presentOk && portOk && httpOk;
  };

  const hasWarning = (obj) => {
    const presentOk = obj.present === true;
    const portOk = obj.port_ok === true;
    const applicable = httpApplicable(obj);
    return presentOk && portOk && applicable && obj.http_ok == null;
  };

  const stateClass = (obj) =>
    isHealthy(obj) ? 'ok' : hasWarning(obj) ? 'warn' : 'bad';

  // --------------------
  // Ağ istekleri
  // --------------------
  const fetchJSON = async (url, options = {}) => {
    const controller = new AbortController();
    const { signal } = controller;

    const res = await fetch(url, {
      ...options,
      signal,
      headers: {
        Accept: 'application/json',
        ...(options.headers || {}),
      },
    });

    if (!res.ok) {
      throw new Error(`HTTP ${res.status}`);
    }
    return res.json();
  };

  const api = {
    health: () => fetchJSON(CONFIG.ENDPOINTS.HEALTH),
    run: () => fetchJSON(CONFIG.ENDPOINTS.RUN, { method: 'POST' }),
    systemd: () => fetchJSON(CONFIG.ENDPOINTS.SYSTEMD),
  };

  // --------------------
  // Port / protokol rozetleri
  // --------------------
  const makeBadges = (name, obj) => {
    const meta = { ...(SERVICE_META[name] || {}), ...(obj || {}) };
    const proto =
      'http_path' in meta || 'expect_status' in meta || 'http_ok' in meta
        ? 'HTTP'
        : 'TCP';

    const items = [];

    if (meta.port != null) {
      items.push(
        el('span', { className: 'badge' }, [
          el('span', { className: 'proto', textContent: proto }),
          el('span', { textContent: ':' }),
          el('code', { textContent: String(meta.port) }),
        ]),
      );
    }

    if (meta.host) {
      items.push(
        el('span', { className: 'badge' }, [
          el('span', { className: 'proto', textContent: 'HOST' }),
          el('span', { textContent: ':' }),
          el('code', { textContent: String(meta.host) }),
        ]),
      );
    }

    if (proto === 'HTTP' && meta.http_path) {
      items.push(
        el('span', { className: 'badge' }, [
          el('span', { className: 'proto', textContent: 'PATH' }),
          el('span', { textContent: ':' }),
          el('code', { textContent: String(meta.http_path) }),
        ]),
      );
    }

    return items.length
      ? el('div', { className: 'badges' }, items)
      : null;
  };

  // --------------------
  // Kart üretimi
  // --------------------
  const makeCard = (name, obj) => {
    const applicable = httpApplicable(obj);
    const sClass = stateClass(obj);
    const httpIcon = applicable ? chipBool(obj.http_ok) : chip('na', 'NA');

    const portErr = Boolean(obj?.errors?.port);
    const httpErr = Boolean(obj?.errors?.http);

    const section = el('section', {
      className: `card ${sClass}`,
      ariaLabel: `${name} durumu`,
      tabIndex: 0,
    });

    const title = el('h2', {}, [
      el('span', { textContent: String(name).toUpperCase() }),
      rh(sClass),
    ]);

    const badges = makeBadges(name, obj);

    const showHttpRow = obj.http_ok === true || obj.http_ok === false;

    const metaChildren = [
      makeRow(CONFIG.LABELS.present, chipBool(obj.present)),
      makeRow(CONFIG.LABELS.port, chipBool(obj.port_ok)),
      showHttpRow ? makeRow(CONFIG.LABELS.http, httpIcon) : null,
      makeDivider(),
      makeRow(
        CONFIG.LABELS.portErr,
        chip(portErr ? 'bad' : 'ok', portErr ? 'Hata' : 'Sorun yok'),
      ),
      showHttpRow
        ? makeRow(
            CONFIG.LABELS.httpErr,
            chip(httpErr ? 'bad' : 'ok', httpErr ? 'Hata' : 'Sorun yok'),
          )
        : null,
    ].filter(Boolean);

    // Sadece BIND9 / NGINX / KEA / DOCKER için systemd satırı ekle
    const upperName = String(name).toUpperCase();
    if (
      ['BIND9', 'NGINX', 'KEA', 'DOCKER'].includes(upperName) &&
      obj.systemd_state
    ) {
      const st = obj.systemd_state; // up / down / unknown
      const cls = st === 'up' ? 'ok' : st === 'down' ? 'bad' : 'na';
      metaChildren.splice(
        2,
        0,
        makeRow(CONFIG.LABELS.systemd, chip(cls, st.toUpperCase())),
      );
    }

    const meta = el('div', { className: 'meta' }, metaChildren);

    section.append(title);
    if (badges) section.append(badges);
    section.append(meta);

    return section;
  };

  // --------------------
  // Render & istatistikler
  // --------------------
  const gridEl = document.getElementById('grid');
  const loadingEl = document.getElementById('loading');

  const renderSkeletons = (n = 6) => {
    const frag = document.createDocumentFragment();
    const tpl = document.getElementById('skeletonCard');
    for (let i = 0; i < n; i++) {
      frag.append(tpl.content.cloneNode(true));
    }
    gridEl.replaceChildren(frag);
  };

  const $total = document.getElementById('statTotal');
  const $ok = document.getElementById('statOk');
  const $bad = document.getElementById('statBad');
  const $score = document.getElementById('score');
  const $scoreVal = document.getElementById('scoreVal');

  const updateStats = (arr) => {
    const total = arr.length;
    const ok = arr.filter(isHealthy).length;
    const bad = arr.filter((o) => !isHealthy(o) && !hasWarning(o)).length;
    const score = total ? Math.round((ok / total) * 100) : 0;

    $total.textContent = total;
    $ok.textContent = ok;
    $bad.textContent = bad;
    $score.style.setProperty('--p', score);
    $scoreVal.textContent = `${score}%`;
    $score.title = `Health Score: ${score}%`;
  };

  const filterQuery = document.getElementById('filter');
  let sortHealthyFirst = false;
  let lastData = null; // { health, systemd }

  const render = (healthData, systemdMap = {}) => {
    // health endpoint'inden gelen objeler + systemd state birleştirme
    const entries = Object.entries(healthData).map(([name, obj]) => {
      const merged = {
        ...(SERVICE_META[name] || {}),
        ...(obj || {}),
      };

      const sys = systemdMap[name.toUpperCase()];
      if (sys && sys.state) {
        merged.systemd_state = sys.state; // up / down / unknown
      }

      return [name, merged];
    });

    const filtered = filterQuery.value
      ? entries.filter(([k]) =>
          k.toLowerCase().includes(filterQuery.value.trim().toLowerCase()),
        )
      : entries;

    const list = sortHealthyFirst
      ? filtered.sort(
          ([, a], [, b]) => Number(isHealthy(b)) - Number(isHealthy(a)),
        )
      : filtered;

    const frag = document.createDocumentFragment();

    if (list.length === 0) {
      frag.append(
        el('p', {
          className: 'empty',
          textContent: 'Gösterilecek servis bulunamadı.',
        }),
      );
    } else {
      list.forEach(([name, obj]) => frag.appendChild(makeCard(name, obj)));
    }

    gridEl.replaceChildren(frag);
    updateStats(entries.map(([, o]) => o));
  };

  // --------------------
  // Yükleme / polling
  // --------------------
  const setLoading = (on) => {
    loadingEl.style.display = on ? 'block' : 'none';
  };

  const pollState = document.getElementById('pollState');
  let pollId = null;

  const startPolling = () => {
    if (pollId) return;
    pollId = setInterval(() => load(), CONFIG.POLL_MS);
    pollState.textContent = 'Polling açık';
  };

  const stopPolling = () => {
    if (!pollId) return;
    clearInterval(pollId);
    pollId = null;
    pollState.textContent = 'Polling kapalı';
  };

  document.addEventListener('visibilitychange', () => {
    if (document.hidden) {
      stopPolling();
    } else {
      startPolling();
    }
  });

  const load = async (opts = { run: false }) => {
    setLoading(true);
    renderSkeletons();

    try {
      // health + systemd aynı anda gelsin
      const [healthData, systemdList] = await Promise.all([
        opts.run ? api.run() : api.health(),
        api.systemd().catch(() => []), // systemd endpoint patlarsa dashboard komple çökmesin
      ]);

      const systemdMap = {};
      if (Array.isArray(systemdList)) {
        for (const item of systemdList) {
          const key = (item.id || '').toUpperCase();
          if (key) systemdMap[key] = item;
        }
      }

      lastData = { health: healthData, systemd: systemdMap };
      render(healthData, systemdMap);

      const $lastRestart = document.getElementById('lastRestart');
      if ($lastRestart) {
        $lastRestart.textContent = new Date().toLocaleTimeString('tr-TR', {
          hour12: false,
        });
      }
    } catch (err) {
      console.error(err);
      gridEl.replaceChildren(
        el('p', {
          className: 'error',
          textContent: `API hatası: ${err.message}`,
        }),
      );
    } finally {
      setLoading(false);
    }
  };

  // --------------------
  // Butonlar / Tema
  // --------------------
  const refreshBtn = document.getElementById('refresh');
  const refreshIcon = document.getElementById('refreshIcon');

  refreshBtn.addEventListener('click', async () => {
    refreshIcon.classList.add('spin');
    try {
      await load({ run: true });
    } finally {
      refreshIcon.classList.remove('spin');
    }
  });

  filterQuery.addEventListener('input', () => {
    if (lastData) {
      render(lastData.health, lastData.systemd);
    }
  });

  const sortBtn = document.getElementById('sort');
  sortBtn.addEventListener('click', () => {
    sortHealthyFirst = !sortHealthyFirst;
    sortBtn.setAttribute('aria-pressed', String(sortHealthyFirst));
    if (lastData) {
      render(lastData.health, lastData.systemd);
    }
  });

  const themeBtn = document.getElementById('theme');
  const themeIcon = document.getElementById('themeIcon');
  const THEME_KEY = 'ife.theme';

  const setThemeMetaColor = (mode) => {
    const prefersLight = matchMedia('(prefers-color-scheme: light)').matches;
    const color =
      mode === 'light'
        ? '#f7f9fc'
        : mode === 'dark'
        ? '#0b1220'
        : prefersLight
        ? '#f7f9fc'
        : '#0b1220';
    document.getElementById('themeColor').setAttribute('content', color);
  };

  const setTheme = (mode) => {
    document.documentElement.setAttribute('data-theme', mode);
    localStorage.setItem(THEME_KEY, mode);
    themeBtn.title = `Tema: ${mode}`;
    themeIcon.innerHTML =
      {
        auto: '<path d="M12 3a9 9 0 1 0 9 9c0-.5 0-1-.1-1.5A6.5 6.5 0 0 1 12 3Z"/>',
        light:
          '<circle cx="12" cy="12" r="5"></circle><g stroke="currentColor" fill="none" stroke-width="2"><path d="M12 1v3"/><path d="M12 20v3"/><path d="M4.2 4.2l2.1 2.1"/><path d="M17.7 17.7l2.1 2.1"/><path d="M1 12h3"/><path d="M20 12h3"/><path d="M4.2 19.8l2.1-2.1"/><path d="M17.7 6.3l2.1-2.1"/></g>',
        dark: '<path d="M21 12.8A9 9 0 1 1 11.2 3a7 7 0 1 0 9.8 9.8Z"></path>',
      }[mode] || '';
    setThemeMetaColor(mode);
  };

  const cycleTheme = () => {
    const current = localStorage.getItem(THEME_KEY) || 'auto';
    const next = current === 'auto' ? 'light' : current === 'light' ? 'dark' : 'auto';
    setTheme(next);
  };

  themeBtn.addEventListener('click', cycleTheme);
  setTheme(localStorage.getItem(THEME_KEY) || 'auto');

  // --------------------
  // İlk yükleme
  // --------------------
  await load();
  startPolling();
</script>
